[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Welcome to my blog! I am a PhD student in University of Edinburgh, researching Multispectral LiDAR development and applications, but my previous experience is in RISC-V and hardware design.\nI have started this blog as a way to dump troubleshooting threads and document things I find interesting."
  },
  {
    "objectID": "posts/rust-abi.html",
    "href": "posts/rust-abi.html",
    "title": "Rust FFI to Julia",
    "section": "",
    "text": "== WIP =="
  },
  {
    "objectID": "posts/rust-abi.html#existing-solution",
    "href": "posts/rust-abi.html#existing-solution",
    "title": "Rust FFI to Julia",
    "section": "Existing solution",
    "text": "Existing solution\nYou can call Julia from Rust, using the exposed C FFI for Julia as leveraged by the jlrs crate, but we are also interested about the reverse."
  },
  {
    "objectID": "posts/rust-abi.html#rust-abi",
    "href": "posts/rust-abi.html#rust-abi",
    "title": "Rust FFI to Julia",
    "section": "Rust ABI",
    "text": "Rust ABI\nThere is currently no agreed way even for calling dylib Rust &lt;-&gt; Rust, known as an ABI, this is because the arguments are not assured to have any layout in memory, they are decided arbitrarily when compiled:\nrust abi_stable crate ðŸ¤£: &gt; the compiler is free to do whatever it pleases with these aspects of your &gt; software: the process by which it does that is explicitly unstable, and &gt; depends on your compiler version, the optimization level you selected, some &gt; llamaâ€™s mood in a wool farm near Berkshireâ€¦ who knows?\n\nStandard strategy: extern \"C\"\nThe standard way to call Rust through a FFI is translating it into to expose a C interface and reuse the system C-ABI. This however causes to drop many of the guarantees Rust tries to make and induces a huge effort boundary of developing software that empowers these two languages to talk, since the translation effort is required two folds as boilerplate glueing code that doesnâ€™t add any value."
  },
  {
    "objectID": "posts/rust-abi.html#interim-solution-to-ease-integration",
    "href": "posts/rust-abi.html#interim-solution-to-ease-integration",
    "title": "Rust FFI to Julia",
    "section": "Interim solution to ease integration",
    "text": "Interim solution to ease integration\n=&gt; Develop RustCall.jl library similar to PyCall.jl which can use cargo packager to build Rust pacakge and generate the necessary C-FFI shims for the two sides as follows:\n\nConstruct a SAT of the public interface of the Rust library\nLimit the scope of supported types to be translated as follows:\n\nRust::Result&lt;T, dyn Box&lt;Error&gt;&gt; &lt;-&gt; Julia::ResultType{T}: indirect C-FFI WIP workout common representation\nRust::Option&lt;T&gt; &lt;-&gt; Julia::Union{T, Nothing}: simply use C++ union\nPrimitives\n\ninteger and floats can be directly converted\nchar*, CString, CStr, Rust::String, Rust::&str, Julia::String, Julia::SubString =&gt; These need special attentions\n\nenums: ==WARN Julia does not have a first class enum type==, but it depends on the global constant declaration similar to C. On the other side, Rust::enum is more similar to a Julia::Union. Also special care needs to be taken as a common design pattern in Julia is to do multiple dispatch on type hierarchies, whereas Rust dispatches over traits.\nstructs: Every Rust struct must be converted to a C repr struct in order to be exposed through the FFI. The same problem seems to occur with Julia\n\nWhile in Julia or structs are considered to be passed by reference, Rust defines, clone, immutable ref or mutable ref.\n\nWIP: Write some simple tests to understand how structs behave in Julia, but from my observations so far, itâ€™s either immutable or mutable ref based on struct definition rather than function definition."
  },
  {
    "objectID": "posts/dll-rust.html",
    "href": "posts/dll-rust.html",
    "title": "Rust sys crate for .DLL",
    "section": "",
    "text": "Building a rust *-sys crate is already quite a standard process to reuse stable library that expose a C-ABI and itâ€™s nicely explained in kornel rust-sys-crate blog. While this works great on Unix or with statically linked library, if you had access to the source, a .DLL requires [1] to load it at runtime.\n[1] Or does it? I only managed to work with a dll using libloading crate, while bindgen itself didnâ€™t manage to link it, no matter what flags I passed to the rust compiler.\n\n\nRust statically links the binaries compiled, however, not the dynamic library which needs to be loaded at runtime. In the case of dynamic library which can be linked at runtime because they are in the linker path, nothing else itâ€™s required. However, if we want the executable to be self maintained, the dynamic library path must be given.\nMy first attempt was to use the OUT_DIR, however this expands in an absolute path which is written in the binary as a constant. Hence, changing the path of the executable or transferring it on another machine, breaks it.\n\n\n\nThe alternative I thought is to embed the .dll inside the executable using embed-resource, extract it at runtime and load it with libloading. This idea doesnâ€™t seem to have been explored before, so I have no certainty yet that is works.\n\n\n\nAdd dependency to build step\n\ncargo add --build embed-resource\n\nWrite the windows resource file as follows in an .rc file.\n\n// Define the DLL as an RCDATA resource\nIDR_MYDLL RCDATA \"vendor_library.dll\"\n\nEmbed the dll inside the executable:\n\nfn main() {\n    embed_resource::compile(\"dll_resource.rc\", embed_resource::NONE)\n        .manifest_optional()\n        .unwrap();\n}\n\nExtract dll at runtime and load it with libloading:\n\nuse winapi::um::libloaderapi::{FindResourceW, LoadResource, SizeofResource, LockResource};\nuse winapi::um::winbase::FreeResource;\nuse winapi::um::winuser::RT_RCDATA;\nuse std::ptr;\nuse std::ffi::OsStr;\nuse std::os::windows::ffi::OsStrExt;\nuse libloading::{Library, Symbol};\n\nunsafe fn extract_and_load_dll() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Convert resource name to wide string\n    let resource_name = OsStr::new(\"IDR_MYDLL\").encode_wide().chain(Some(0)).collect::&lt;Vec&lt;_&gt;&gt;();\n    \n    // Locate the resource\n    let h_resource = FindResourceW(\n        ptr::null_mut(),\n        resource_name.as_ptr(),\n        RT_RCDATA\n    );\n    \n    // Load and lock the resource\n    let h_global = LoadResource(ptr::null_mut(), h_resource);\n    let dll_data = LockResource(h_global) as *const u8;\n    let dll_size = SizeofResource(ptr::null_mut(), h_resource) as usize;\n    \n    // Write to temp file\n    let temp_path = std::env::temp_dir().join(\"vendor_library.dll\");\n    std::fs::write(&temp_path, std::slice::from_raw_parts(dll_data, dll_size))?;\n    \n    // Load the DLL\n    let lib = Library::new(&temp_path)?;\n    let func: Symbol&lt;unsafe extern \"C\" fn() -&gt; i32&gt; = lib.get(b\"example_function\")?;\n    println!(\"Result: {}\", func());\n    \n    // Cleanup (optional)\n    FreeResource(h_global);\n    std::fs::remove_file(temp_path)?;\n    \n    Ok(())\n}\nA more detailed example of how to work with embedded resources in Windows is shown in embed and extract binaries into/from exe as resources. In our case the resource type is RCDATA to describe a custom binary."
  },
  {
    "objectID": "posts/dll-rust.html#statically-linked",
    "href": "posts/dll-rust.html#statically-linked",
    "title": "Rust sys crate for .DLL",
    "section": "",
    "text": "Rust statically links the binaries compiled, however, not the dynamic library which needs to be loaded at runtime. In the case of dynamic library which can be linked at runtime because they are in the linker path, nothing else itâ€™s required. However, if we want the executable to be self maintained, the dynamic library path must be given.\nMy first attempt was to use the OUT_DIR, however this expands in an absolute path which is written in the binary as a constant. Hence, changing the path of the executable or transferring it on another machine, breaks it."
  },
  {
    "objectID": "posts/dll-rust.html#embed-resource",
    "href": "posts/dll-rust.html#embed-resource",
    "title": "Rust sys crate for .DLL",
    "section": "",
    "text": "The alternative I thought is to embed the .dll inside the executable using embed-resource, extract it at runtime and load it with libloading. This idea doesnâ€™t seem to have been explored before, so I have no certainty yet that is works.\n\n\n\nAdd dependency to build step\n\ncargo add --build embed-resource\n\nWrite the windows resource file as follows in an .rc file.\n\n// Define the DLL as an RCDATA resource\nIDR_MYDLL RCDATA \"vendor_library.dll\"\n\nEmbed the dll inside the executable:\n\nfn main() {\n    embed_resource::compile(\"dll_resource.rc\", embed_resource::NONE)\n        .manifest_optional()\n        .unwrap();\n}\n\nExtract dll at runtime and load it with libloading:\n\nuse winapi::um::libloaderapi::{FindResourceW, LoadResource, SizeofResource, LockResource};\nuse winapi::um::winbase::FreeResource;\nuse winapi::um::winuser::RT_RCDATA;\nuse std::ptr;\nuse std::ffi::OsStr;\nuse std::os::windows::ffi::OsStrExt;\nuse libloading::{Library, Symbol};\n\nunsafe fn extract_and_load_dll() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Convert resource name to wide string\n    let resource_name = OsStr::new(\"IDR_MYDLL\").encode_wide().chain(Some(0)).collect::&lt;Vec&lt;_&gt;&gt;();\n    \n    // Locate the resource\n    let h_resource = FindResourceW(\n        ptr::null_mut(),\n        resource_name.as_ptr(),\n        RT_RCDATA\n    );\n    \n    // Load and lock the resource\n    let h_global = LoadResource(ptr::null_mut(), h_resource);\n    let dll_data = LockResource(h_global) as *const u8;\n    let dll_size = SizeofResource(ptr::null_mut(), h_resource) as usize;\n    \n    // Write to temp file\n    let temp_path = std::env::temp_dir().join(\"vendor_library.dll\");\n    std::fs::write(&temp_path, std::slice::from_raw_parts(dll_data, dll_size))?;\n    \n    // Load the DLL\n    let lib = Library::new(&temp_path)?;\n    let func: Symbol&lt;unsafe extern \"C\" fn() -&gt; i32&gt; = lib.get(b\"example_function\")?;\n    println!(\"Result: {}\", func());\n    \n    // Cleanup (optional)\n    FreeResource(h_global);\n    std::fs::remove_file(temp_path)?;\n    \n    Ok(())\n}\nA more detailed example of how to work with embedded resources in Windows is shown in embed and extract binaries into/from exe as resources. In our case the resource type is RCDATA to describe a custom binary."
  },
  {
    "objectID": "posts/train-bike.html",
    "href": "posts/train-bike.html",
    "title": "Travel by Bicycle on Public Transport",
    "section": "",
    "text": "Welcome fellow cyclist or soon to be! To cut it short I am pouring here my ideas about improving the way we can plan travels when it comes to minimising our carbon footprint and enjoy maximising our time for what matters, rather than endless hours spent in airports and driving a car, which let us be honest, it is lost time that you will never get back.\n\n\n\n\n\n\n\n\nTip\n\n\n\nIf not interested, please jump to the technical part in SectionÂ 1.2.\n\n\nEven though I didnâ€™t have a clear idea about the impact climate change had when I used to be in high school, I decided that I donâ€™t need a driving licence to contribute to green house gas emissions, while all my other classmates got one.\nThen later in university, cycling became my main way of commuting while I was living in Oxford, which is a very welcome city to start cycling since the centre is restricted to bicycles, buses and taxis, but few cities in UK have this benefit, unfortunately. During my undergraduate there I lived in house with a Polish PhD student who was cycling about 50 km every other day and pushed my to explore even more of the surroundings, which by the way are very pretty.\nAfter my graduation, I continued this style of life, while a component has been added to the commute chain, travelling by train. I started working right away in a far east town in London, Rainham , and initially I used to take the train and cycle forth and back (60km total) for 2-3 days per week to get to my job. The GWR trains Oxford to London had bike space all the time available at the time of day I was travelling, but once in a while it would happen that , without a bike reservation, I had to implore the staff to let me on the corridor, which I notice to be a hard rule not to be accepted any more. I did this for 2 months, then I moved in Isle of Dogs and the commute shortened to 36 km total per day.\nAfter one year in London, I moved to Cambridge for a new job and with this a new lifestyle started. If you ever lived in this area you might know that the area around Cambridge is one of the most boring in the UK. Because I really like to explore the natural world, I started travelling, and hence is where my real troubles with travelling on trains with my bike started.\n\n\nNormally the train Cambridge-London accepts bicycles, apart from the peak hours. But if you want to travel longer distances, like going north to Peak District or all the way to Scotland, there are a maximum of 4 bike spaces for 500-600 passengers train on LNER and Avanti, or none for Lumo. The train companies donâ€™t have an incentive to improve the integration of cycling and travelling by train, as for them there is no pecuniary benefit, but on the contrary, since the bike spaces are free. Policymakers are probably better to discuss how this problem could be resolved, but here I am going to focus on what is within our power to make this activity easier.\nFurthermore, not many coaches provide bike spaces either and for the one that do, it varies if you need to book, or it is first come, first served.\n\n\n\nAbove, I have focused on the problem in UK as I live here, but the same stays true for Europe.\nLast year, in the summer of 2024, because I decided to stop taking any flights, I travelled from Cambridge to Romania on my modified single-speed Mango bike and back. However, due to time constraints, I had to cut it short and take the train on a section. Well, it wasnâ€™t easy either to cross to Europe on the Eurostar, or find a train that would accept bicycles on a good chunk for my travel (about 600km).\n\n\n\n\n\n\nTip\n\n\n\nTODO: Add diagram of my trip, splitting public tranport and cycling paths such that I can depict the problem better.\n\n\nThis journey discouraged me if I can do this any further. If you travel UK-Germany for example, that is not too bad, but if you go all the way to Romania, there are not many options, and the romanian trains are despicable.\n\n\n\nBesides the admin hasle of trying to figure out what trains accept bicycles and on what trains still have bike spaces available, there is also the travelling salesman problem of what route you should take to get from point A to B given a certain cycling speed.\nNow I live in Scotland and the problem amplifies even further since the highlands is sparse populated, hence also the train stations and tracks are fewer. So if you wanted to travel from point A to B, you have to check many choices of how to combine cycling, with train, ferry or buses.\n\n\n\n\n\n\nTip\n\n\n\nTODO: Add example for one of my travels in Scotland.\n\n\n\n\n\n\nI spent to much time being upset or angry on the lack of options or the money Iâ€™ve lost because I had to change tickets to allow me to travel this way. Hence, the only way to move forward in doing what I like, to be free, to get to any point in the world, while preserving the environment we have for generation to have, is to try to ease the way such multiple green choice transportations can be combined and to make sure the travel is possible that way.\nSolutions to this problem vary depending what your focus is, as a journalist you might write many articles to bring awareness, as a political activist you would try to push policymakers to move the game in that direction, if you are involved in the government or have an official political position, you could change the game from within. I am none of these, but what I am good at is being an engineer and as an engineer I would like to have a tool that can ease the way I can live given the rules of the game I am playing.\nHence, the problem I described above is two-fold:\n\nTravelling salesman using multiple choice public transport and freestyle travel (cycle or hiking)\nCheck the availability of bike spaces on the public transport choices\n\n\n\n\n\nWhile the first problem might be achievable for only public transport as the nodes need to be connected, if you cycle the amount of choices for each station increases very fast with the radius you are willing to travel.\nBut let us assume first that we only have public transport to care about. For the national rail, there is a public API you can use to query the routes, but for buses and ferries, you will need to check with each company individually.\nIdeally, you would have an API for each one of these that can give us a good confidence about the results, but what we are left with is building a heterogeneous querying or scrapping the web for information, which can be very expensive, hence some memoization is required.\nThe long term solution could be to commercialise such a product and pay brokers that can give you reliable information about the routes.\nMoving back to adding the cycling or hiking in the forefront, services as Google Maps are already hard to achieve to integrate public transport with short walks, extending the range of reaching the public transport station, makes it much more computationally complex as shown in ?@fig-exponential-travelling-salesman.\n\n\n\n\n\n\nWarning\n\n\n\nIncreased difficulty to find best A-&gt;B route for this problem needs to be shown in a visual example.\n\n\n\n\n\nAs we discussed above, the transparency of these transportations method is an issue, and becomes quite problematic with bike spaces, as there is no information on the available API in the national rail about how many bike spaces are available on the specified route.\nThe way I had to do it so far was to trust Trainline new added feature about bikes, which turned out not to be very reliable as reason for why I am writing this blogpost.\nIt seems PlanarNetwork distributed transit API might have some fields describing bike allowance, but this needs to be investigated and potentially talked with the developers if we can move this forward.\nAlternatively, it would to have a bot developed that tries to book a train ticket for a route on the official train operator website and check if a bike reservation can be made. This is probably quite tricky to make, but only certain solution that I see moving forward for now.\n\n\n\n\nThere are many requirements and potential solutions that need to be discussed, above I only wrote the very basic high-level description of the problem that I want to solve. If you are interested to discuss more about this and have ideas to contribute please contact me.\n\n\n\n\nMy focus to start with will be trying to sort the travellings-salesman of bike + train space and see if I can ease up how I can explore Scotland using this lifestyle.\nOnce this is completed, it will give me more certainty that I can look into bike reservations on the train.\nFinally, adding more options for public transit should be added easily, given that I leave enough flexibility in how the routes are structured and described for the trains."
  },
  {
    "objectID": "posts/train-bike.html#short-story-about-me",
    "href": "posts/train-bike.html#short-story-about-me",
    "title": "Travel by Bicycle on Public Transport",
    "section": "",
    "text": "Tip\n\n\n\nIf not interested, please jump to the technical part in SectionÂ 1.2.\n\n\nEven though I didnâ€™t have a clear idea about the impact climate change had when I used to be in high school, I decided that I donâ€™t need a driving licence to contribute to green house gas emissions, while all my other classmates got one.\nThen later in university, cycling became my main way of commuting while I was living in Oxford, which is a very welcome city to start cycling since the centre is restricted to bicycles, buses and taxis, but few cities in UK have this benefit, unfortunately. During my undergraduate there I lived in house with a Polish PhD student who was cycling about 50 km every other day and pushed my to explore even more of the surroundings, which by the way are very pretty.\nAfter my graduation, I continued this style of life, while a component has been added to the commute chain, travelling by train. I started working right away in a far east town in London, Rainham , and initially I used to take the train and cycle forth and back (60km total) for 2-3 days per week to get to my job. The GWR trains Oxford to London had bike space all the time available at the time of day I was travelling, but once in a while it would happen that , without a bike reservation, I had to implore the staff to let me on the corridor, which I notice to be a hard rule not to be accepted any more. I did this for 2 months, then I moved in Isle of Dogs and the commute shortened to 36 km total per day.\nAfter one year in London, I moved to Cambridge for a new job and with this a new lifestyle started. If you ever lived in this area you might know that the area around Cambridge is one of the most boring in the UK. Because I really like to explore the natural world, I started travelling, and hence is where my real troubles with travelling on trains with my bike started.\n\n\nNormally the train Cambridge-London accepts bicycles, apart from the peak hours. But if you want to travel longer distances, like going north to Peak District or all the way to Scotland, there are a maximum of 4 bike spaces for 500-600 passengers train on LNER and Avanti, or none for Lumo. The train companies donâ€™t have an incentive to improve the integration of cycling and travelling by train, as for them there is no pecuniary benefit, but on the contrary, since the bike spaces are free. Policymakers are probably better to discuss how this problem could be resolved, but here I am going to focus on what is within our power to make this activity easier.\nFurthermore, not many coaches provide bike spaces either and for the one that do, it varies if you need to book, or it is first come, first served.\n\n\n\nAbove, I have focused on the problem in UK as I live here, but the same stays true for Europe.\nLast year, in the summer of 2024, because I decided to stop taking any flights, I travelled from Cambridge to Romania on my modified single-speed Mango bike and back. However, due to time constraints, I had to cut it short and take the train on a section. Well, it wasnâ€™t easy either to cross to Europe on the Eurostar, or find a train that would accept bicycles on a good chunk for my travel (about 600km).\n\n\n\n\n\n\nTip\n\n\n\nTODO: Add diagram of my trip, splitting public tranport and cycling paths such that I can depict the problem better.\n\n\nThis journey discouraged me if I can do this any further. If you travel UK-Germany for example, that is not too bad, but if you go all the way to Romania, there are not many options, and the romanian trains are despicable.\n\n\n\nBesides the admin hasle of trying to figure out what trains accept bicycles and on what trains still have bike spaces available, there is also the travelling salesman problem of what route you should take to get from point A to B given a certain cycling speed.\nNow I live in Scotland and the problem amplifies even further since the highlands is sparse populated, hence also the train stations and tracks are fewer. So if you wanted to travel from point A to B, you have to check many choices of how to combine cycling, with train, ferry or buses.\n\n\n\n\n\n\nTip\n\n\n\nTODO: Add example for one of my travels in Scotland."
  },
  {
    "objectID": "posts/train-bike.html#sec-application-requirements",
    "href": "posts/train-bike.html#sec-application-requirements",
    "title": "Travel by Bicycle on Public Transport",
    "section": "",
    "text": "I spent to much time being upset or angry on the lack of options or the money Iâ€™ve lost because I had to change tickets to allow me to travel this way. Hence, the only way to move forward in doing what I like, to be free, to get to any point in the world, while preserving the environment we have for generation to have, is to try to ease the way such multiple green choice transportations can be combined and to make sure the travel is possible that way.\nSolutions to this problem vary depending what your focus is, as a journalist you might write many articles to bring awareness, as a political activist you would try to push policymakers to move the game in that direction, if you are involved in the government or have an official political position, you could change the game from within. I am none of these, but what I am good at is being an engineer and as an engineer I would like to have a tool that can ease the way I can live given the rules of the game I am playing.\nHence, the problem I described above is two-fold:\n\nTravelling salesman using multiple choice public transport and freestyle travel (cycle or hiking)\nCheck the availability of bike spaces on the public transport choices\n\n\n\n\n\nWhile the first problem might be achievable for only public transport as the nodes need to be connected, if you cycle the amount of choices for each station increases very fast with the radius you are willing to travel.\nBut let us assume first that we only have public transport to care about. For the national rail, there is a public API you can use to query the routes, but for buses and ferries, you will need to check with each company individually.\nIdeally, you would have an API for each one of these that can give us a good confidence about the results, but what we are left with is building a heterogeneous querying or scrapping the web for information, which can be very expensive, hence some memoization is required.\nThe long term solution could be to commercialise such a product and pay brokers that can give you reliable information about the routes.\nMoving back to adding the cycling or hiking in the forefront, services as Google Maps are already hard to achieve to integrate public transport with short walks, extending the range of reaching the public transport station, makes it much more computationally complex as shown in ?@fig-exponential-travelling-salesman.\n\n\n\n\n\n\nWarning\n\n\n\nIncreased difficulty to find best A-&gt;B route for this problem needs to be shown in a visual example.\n\n\n\n\n\nAs we discussed above, the transparency of these transportations method is an issue, and becomes quite problematic with bike spaces, as there is no information on the available API in the national rail about how many bike spaces are available on the specified route.\nThe way I had to do it so far was to trust Trainline new added feature about bikes, which turned out not to be very reliable as reason for why I am writing this blogpost.\nIt seems PlanarNetwork distributed transit API might have some fields describing bike allowance, but this needs to be investigated and potentially talked with the developers if we can move this forward.\nAlternatively, it would to have a bot developed that tries to book a train ticket for a route on the official train operator website and check if a bike reservation can be made. This is probably quite tricky to make, but only certain solution that I see moving forward for now.\n\n\n\n\nThere are many requirements and potential solutions that need to be discussed, above I only wrote the very basic high-level description of the problem that I want to solve. If you are interested to discuss more about this and have ideas to contribute please contact me."
  },
  {
    "objectID": "posts/train-bike.html#implementation-plan",
    "href": "posts/train-bike.html#implementation-plan",
    "title": "Travel by Bicycle on Public Transport",
    "section": "",
    "text": "My focus to start with will be trying to sort the travellings-salesman of bike + train space and see if I can ease up how I can explore Scotland using this lifestyle.\nOnce this is completed, it will give me more certainty that I can look into bike reservations on the train.\nFinally, adding more options for public transit should be added easily, given that I leave enough flexibility in how the routes are structured and described for the trains."
  },
  {
    "objectID": "posts/unreal-engine-nix.html",
    "href": "posts/unreal-engine-nix.html",
    "title": "Unreal Engine on Nix (Linux)",
    "section": "",
    "text": "The Unreal Engine will be useful for us to generate synthetic data for our research. They provide a prebuild binary for Ubuntu and Centos, however, since I am running NixOS (non FHS system), the prebuilt binary canâ€™t link to the requested libraries.\nTL;DR I have tried a few approaches to get it working on Nix or LXD under Nix, however, in the end I resorted to using their docker image."
  },
  {
    "objectID": "posts/unreal-engine-nix.html#fhsuserenv",
    "href": "posts/unreal-engine-nix.html#fhsuserenv",
    "title": "Unreal Engine on Nix (Linux)",
    "section": "FHSUserEnv",
    "text": "FHSUserEnv\nIn some cases workaround to build and FHS environment fixes the issue. In this scenario, the program is really big (larger than 30GB), so populating a derivation with that amount of extra storage is not acceptable for my laptop, but I have tried to do so:\n{ pkgs ? import&lt;nixpkgs&gt;{}}:\n#stdenv, buildFHSUserEnv, fetchFromGitHub, git, python3, mono, clang, cmake, libGL, xorg }:\n\nlet\n  inherit (pkgs) stdenv buildFHSUserEnv fetchFromGitHub git python3 mono clang cmake libGL xorg;\n  unreal-engine = stdenv.mkDerivation {\n    pname = \"unreal-engine\";\n    version = \"5.4.4\"; # Adjust version as needed\n\n    src = ./.;\n\n    nativeBuildInputs = [ git python3 pkgs.bash stdenv.cc.cc stdenv.cc.cc.lib];\n\n\n    buildInputs = [ \n        libGL \n        xorg.libXi \n        xorg.libXcursor \n        xorg.libXrandr \n        xorg.libXinerama \n    ];\n\n    buildPhase = ''\n      patchShebangs .\n      # Run Setup.sh\n      ./Setup.sh\n      \n      # Generate project files\n      ./GenerateProjectFiles.sh\n      \n      # Build the engine\n      make\n    '';\n\n    installPhase = ''\n      mkdir -p $out\n      cp -r . $out\n    '';\n\n    meta = with pkgs.lib; {\n      description = \"Unreal Engine source code\";\n      homepage = \"https://www.unrealengine.com/\";\n      license = licenses.unfree;\n      platforms = platforms.linux;\n    };\n  };\n\nin\nbuildFHSUserEnv {\n  name = \"unreal-engine-env\";\n  targetPkgs = pkgs: with pkgs; [\n    unreal-engine\n    # Add any additional runtime dependencies here\n  ];\n  runScript = \"bash\";\n}\npatchShebangs overwrites the #!/usb/bin/&lt;executable&gt; paths with the nixpkgs paths in order to fix the build issue. However, this still seems to error with a binary trying to call an utility from a hard-coded path."
  },
  {
    "objectID": "posts/unreal-engine-nix.html#nix-ld",
    "href": "posts/unreal-engine-nix.html#nix-ld",
    "title": "Unreal Engine on Nix (Linux)",
    "section": "nix-ld",
    "text": "nix-ld\nAlso tried to setup an environment using nix-ld to run with libraries paths being patched automagically. ==IDK how nix-ld actually works as I have checked out their source code==\nwith import &lt;nixpkgs&gt; {};\nmkShell {\n  NIX_LD_LIBRARY_PATH = lib.makeLibraryPath [\n    stdenv.cc.cc\n    stdenv.cc.cc.lib\n    SDL2\n    openssl\n    xorg.libX11\n    xorg.libXext\n    xorg.libXcursor\n    xorg.libXrandr\n    xorg.libXinerama\n    libGL\n    libuv\n    # ...\n  ];\n  NIX_LD = lib.fileContents \"${stdenv.cc}/nix-support/dynamic-linker\";\n  shellHook = ''\n    #LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$NIX_LD_LIBRARY_PATH:${pkgs.stdenv.cc.cc.lib}/lib\n    LD_LIBRARY_PATH=${pkgs.stdenv.cc.cc.lib}/lib\n  '';\n}"
  },
  {
    "objectID": "posts/unreal-engine-nix.html#lxd",
    "href": "posts/unreal-engine-nix.html#lxd",
    "title": "Unreal Engine on Nix (Linux)",
    "section": "LXD",
    "text": "LXD\nNext obvious answer to me was to work in a Distro that UnrealEngine supports by default. Getting LXD to work in NixOS had itâ€™s own complication with forwarding network.\nIn order to get LXD working properly on NixOS, the following is added to the configuration.nix:\n  # Adding lxd and overriding the package\n  virtualisation = {\n    lxd = {\n      enable=true;\n\n      # using the package of our overlay\n      # package = pkgs.lxd-vmx.lxd.override {useQemu = true;};\n      recommendedSysctlSettings=true;\n    };\n\n    lxc = {\n      enable = true;\n      lxcfs.enable = true;\n\n      # This enables lxcfs, which is a FUSE fs that sets up some things so that\n      # things like /proc and cgroups work better in lxd containers.\n      # See https://linuxcontainers.org/lxcfs/introduction/ for more info.\n      #\n      # Also note that the lxcfs NixOS option says that in order to make use of\n      # lxcfs in the container, you need to include the following NixOS setting\n      # in the NixOS container guest configuration:\n      #\n      defaultConfig = \"lxc.include = ''${pkgs.lxcfs}/share/lxc/config/common.conf.d/00-lxcfs.conf\";\n\n      # TODO Add systemConfig to store lxcpath and btrfs.root paths\n      #systemConfig =\n      #  ''\n      #    lxc.lxcpath = /var/lib/lxd/storage-pools # The location in which all containers are stored.\n      #  '';\n    };\n\n    libvirtd = {\n      enable = true;\n      qemu.runAsRoot = true;\n    };\n  };\n\n  # kernel module for forwarding to work\n  boot.kernelModules = [ \"nf_nat_ftp\" ];\n\n  # Set up networking bridge for LXD\n  networking = {\n    bridges = {\n      lxdbr0 = {\n        interfaces = [];\n      };\n    };\n    nat = {\n      enable = true;\n      internalInterfaces = [\"lxdbr0\"];\n      externalInterface = \"eth0\"; # Replace with your actual external interface\n    };\n  };\n  networking.firewall.trustedInterfaces = [ \"lxdbr0\" ];\nWhile the github repository compiled, it didnâ€™t finish linking due to an error I couldnâ€™t debug. ==I havenâ€™t tried the prebuilt binary for this one=="
  },
  {
    "objectID": "posts/unreal-engine-nix.html#docker",
    "href": "posts/unreal-engine-nix.html#docker",
    "title": "Unreal Engine on Nix (Linux)",
    "section": "Docker",
    "text": "Docker\nLuckly it seems that EpicGames provide a docker image for their releases of Unreal as well.\nFirst of all, become a member of the EpicGames github group in order to access repositories and registry. Follow Getting started with Unreal Engine source code access.\nIn order to access them you need to generate a personal autorisation token: Profile &gt; Settings &gt; Developer settings &gt; Personal access token &gt; Tokens (classic). Enable read: packages for this token. Then login into the ghcr with docker:\nexport GH_PAT=&lt;copy_token_here&gt;\necho $GH_PAT | docker login ghcr.io -u &lt;username&gt; --password-stdin\nThen pull the image of interest, i.e.\ndocker pull ghcr.io/epicgames/unreal-engine:dev-5.4.4\nNow in order to run your container with Xserver support and GPU passthrough, run:\ndocker run --rm -ti --device nvidia.com/gpu=all -v/tmp/.X11-unix:/tmp/.X11-unix:rw -e DISPLAY --network host ghcr.io/epicgames/unreal-engine:dev-5.4.3 bash\n\nGPU, Xserver and network to Docker\nThere are a few details to iron out in order to make the above command work. For NixOS the followings:\n\nEnsure docker is enable and has support for nvidia:\n\n  virtualisation.docker = {\n    enable = true;\n  };\n  hardware.nvidia-container-toolkit.enable = true;\n\n  users.users.cristi.extraGroups = [\"docker\"];\n\n  environment.systemPackages = with pkgs; [\n    docker\n  ];\n\nEnsure xserver is enabled and can allow docker\n\nservices.xserver = {\n  enable = true;\n  displayManager.lightdm.enable = true;\n};\nenvironment.systemPackages = with pkgs; [ \n  xorg.xhost # Necessary for allowing docker X11 access \n];\n\nxhost add docker to local drivers with xhost +local:docker or configure from NixOS (warn: I havenâ€™t tried this yet):\n\nsystemd.services.xhost-docker = {\n  description = \"Allow Docker containers to access X11\";\n  after = [ \"display-manager.service\" ];\n  script = ''\n    ${pkgs.xorg.xhost}/bin/xhost +local:docker\n  '';\n  serviceConfig = {\n    Type = \"oneshot\";\n    User = \"root\";\n  };\n  wantedBy = [ \"multi-user.target\" ];\n};"
  },
  {
    "objectID": "posts/unreal-engine-nix.html#more-info",
    "href": "posts/unreal-engine-nix.html#more-info",
    "title": "Unreal Engine on Nix (Linux)",
    "section": "More Info",
    "text": "More Info\nMore information about using Unreal in containers can be found at UnrealContainers, showcasing how to setup docker with correct flags to enable different functionalities.\nFor information on Linux setup: https://dev.epicgames.com/documentation/en-us/unreal-engine/linux-development-quickstart-for-unreal-engine"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesnâ€™t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "crisbour Blog",
    "section": "",
    "text": "Travel by Bicycle on Public Transport\n\n\n\nbike\n\ntrain\n\npublic-transit\n\napp\n\n\n\n\n\n\n\n\n\nMay 10, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nRust sys crate for .DLL\n\n\n\nrust\n\nwindows\n\nffi\n\n\n\n\n\n\n\n\n\nApril 08, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nRust FFI to Julia\n\n\n\nrust\n\nffi\n\njulia\n\n\n\n\n\n\n\n\n\nFebruary 11, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nUnreal Engine on Nix (Linux)\n\n\n\nnix\n\ncontainer\n\nsetup\n\n\n\n\n\n\n\n\n\nNovember 02, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nNovember 02, 2024\n\n\n\n\n\nNo matching items"
  }
]