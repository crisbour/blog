[
  {
    "objectID": "posts/unreal-engine-nix.html",
    "href": "posts/unreal-engine-nix.html",
    "title": "Unreal Engine on Nix (Linux)",
    "section": "",
    "text": "The Unreal Engine will be useful for us to generate synthetic data for our research. They provide a prebuild binary for Ubuntu and Centos, however, since I am running NixOS (non FHS system), the prebuilt binary can’t link to the requested libraries.\nTL;DR I have tried a few approaches to get it working on Nix or LXD under Nix, however, in the end I resorted to using their docker image."
  },
  {
    "objectID": "posts/unreal-engine-nix.html#fhsuserenv",
    "href": "posts/unreal-engine-nix.html#fhsuserenv",
    "title": "Unreal Engine on Nix (Linux)",
    "section": "FHSUserEnv",
    "text": "FHSUserEnv\nIn some cases workaround to build and FHS environment fixes the issue. In this scenario, the program is really big (larger than 30GB), so populating a derivation with that amount of extra storage is not acceptable for my laptop, but I have tried to do so:\n{ pkgs ? import&lt;nixpkgs&gt;{}}:\n#stdenv, buildFHSUserEnv, fetchFromGitHub, git, python3, mono, clang, cmake, libGL, xorg }:\n\nlet\n  inherit (pkgs) stdenv buildFHSUserEnv fetchFromGitHub git python3 mono clang cmake libGL xorg;\n  unreal-engine = stdenv.mkDerivation {\n    pname = \"unreal-engine\";\n    version = \"5.4.4\"; # Adjust version as needed\n\n    src = ./.;\n\n    nativeBuildInputs = [ git python3 pkgs.bash stdenv.cc.cc stdenv.cc.cc.lib];\n\n\n    buildInputs = [ \n        libGL \n        xorg.libXi \n        xorg.libXcursor \n        xorg.libXrandr \n        xorg.libXinerama \n    ];\n\n    buildPhase = ''\n      patchShebangs .\n      # Run Setup.sh\n      ./Setup.sh\n      \n      # Generate project files\n      ./GenerateProjectFiles.sh\n      \n      # Build the engine\n      make\n    '';\n\n    installPhase = ''\n      mkdir -p $out\n      cp -r . $out\n    '';\n\n    meta = with pkgs.lib; {\n      description = \"Unreal Engine source code\";\n      homepage = \"https://www.unrealengine.com/\";\n      license = licenses.unfree;\n      platforms = platforms.linux;\n    };\n  };\n\nin\nbuildFHSUserEnv {\n  name = \"unreal-engine-env\";\n  targetPkgs = pkgs: with pkgs; [\n    unreal-engine\n    # Add any additional runtime dependencies here\n  ];\n  runScript = \"bash\";\n}\npatchShebangs overwrites the #!/usb/bin/&lt;executable&gt; paths with the nixpkgs paths in order to fix the build issue. However, this still seems to error with a binary trying to call an utility from a hard-coded path."
  },
  {
    "objectID": "posts/unreal-engine-nix.html#nix-ld",
    "href": "posts/unreal-engine-nix.html#nix-ld",
    "title": "Unreal Engine on Nix (Linux)",
    "section": "nix-ld",
    "text": "nix-ld\nAlso tried to setup an environment using nix-ld to run with libraries paths being patched automagically. ==IDK how nix-ld actually works as I have checked out their source code==\nwith import &lt;nixpkgs&gt; {};\nmkShell {\n  NIX_LD_LIBRARY_PATH = lib.makeLibraryPath [\n    stdenv.cc.cc\n    stdenv.cc.cc.lib\n    SDL2\n    openssl\n    xorg.libX11\n    xorg.libXext\n    xorg.libXcursor\n    xorg.libXrandr\n    xorg.libXinerama\n    libGL\n    libuv\n    # ...\n  ];\n  NIX_LD = lib.fileContents \"${stdenv.cc}/nix-support/dynamic-linker\";\n  shellHook = ''\n    #LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$NIX_LD_LIBRARY_PATH:${pkgs.stdenv.cc.cc.lib}/lib\n    LD_LIBRARY_PATH=${pkgs.stdenv.cc.cc.lib}/lib\n  '';\n}"
  },
  {
    "objectID": "posts/unreal-engine-nix.html#lxd",
    "href": "posts/unreal-engine-nix.html#lxd",
    "title": "Unreal Engine on Nix (Linux)",
    "section": "LXD",
    "text": "LXD\nNext obvious answer to me was to work in a Distro that UnrealEngine supports by default. Getting LXD to work in NixOS had it’s own complication with forwarding network.\nIn order to get LXD working properly on NixOS, the following is added to the configuration.nix:\n  # Adding lxd and overriding the package\n  virtualisation = {\n    lxd = {\n      enable=true;\n\n      # using the package of our overlay\n      # package = pkgs.lxd-vmx.lxd.override {useQemu = true;};\n      recommendedSysctlSettings=true;\n    };\n\n    lxc = {\n      enable = true;\n      lxcfs.enable = true;\n\n      # This enables lxcfs, which is a FUSE fs that sets up some things so that\n      # things like /proc and cgroups work better in lxd containers.\n      # See https://linuxcontainers.org/lxcfs/introduction/ for more info.\n      #\n      # Also note that the lxcfs NixOS option says that in order to make use of\n      # lxcfs in the container, you need to include the following NixOS setting\n      # in the NixOS container guest configuration:\n      #\n      defaultConfig = \"lxc.include = ''${pkgs.lxcfs}/share/lxc/config/common.conf.d/00-lxcfs.conf\";\n\n      # TODO Add systemConfig to store lxcpath and btrfs.root paths\n      #systemConfig =\n      #  ''\n      #    lxc.lxcpath = /var/lib/lxd/storage-pools # The location in which all containers are stored.\n      #  '';\n    };\n\n    libvirtd = {\n      enable = true;\n      qemu.runAsRoot = true;\n    };\n  };\n\n  # kernel module for forwarding to work\n  boot.kernelModules = [ \"nf_nat_ftp\" ];\n\n  # Set up networking bridge for LXD\n  networking = {\n    bridges = {\n      lxdbr0 = {\n        interfaces = [];\n      };\n    };\n    nat = {\n      enable = true;\n      internalInterfaces = [\"lxdbr0\"];\n      externalInterface = \"eth0\"; # Replace with your actual external interface\n    };\n  };\n  networking.firewall.trustedInterfaces = [ \"lxdbr0\" ];\nWhile the github repository compiled, it didn’t finish linking due to an error I couldn’t debug. ==I haven’t tried the prebuilt binary for this one=="
  },
  {
    "objectID": "posts/unreal-engine-nix.html#docker",
    "href": "posts/unreal-engine-nix.html#docker",
    "title": "Unreal Engine on Nix (Linux)",
    "section": "Docker",
    "text": "Docker\nLuckly it seems that EpicGames provide a docker image for their releases of Unreal as well.\nFirst of all, become a member of the EpicGames github group in order to access repositories and registry. Follow Getting started with Unreal Engine source code access.\nIn order to access them you need to generate a personal autorisation token: Profile &gt; Settings &gt; Developer settings &gt; Personal access token &gt; Tokens (classic). Enable read: packages for this token. Then login into the ghcr with docker:\nexport GH_PAT=&lt;copy_token_here&gt;\necho $GH_PAT | docker login ghcr.io -u &lt;username&gt; --password-stdin\nThen pull the image of interest, i.e.\ndocker pull ghcr.io/epicgames/unreal-engine:dev-5.4.4\nNow in order to run your container with Xserver support and GPU passthrough, run:\ndocker run --rm -ti --device nvidia.com/gpu=all -v/tmp/.X11-unix:/tmp/.X11-unix:rw -e DISPLAY --network host ghcr.io/epicgames/unreal-engine:dev-5.4.3 bash\n\nGPU, Xserver and network to Docker\nThere are a few details to iron out in order to make the above command work. For NixOS the followings:\n\nEnsure docker is enable and has support for nvidia:\n\n  virtualisation.docker = {\n    enable = true;\n  };\n  hardware.nvidia-container-toolkit.enable = true;\n\n  users.users.cristi.extraGroups = [\"docker\"];\n\n  environment.systemPackages = with pkgs; [\n    docker\n  ];\n\nEnsure xserver is enabled and can allow docker\n\nservices.xserver = {\n  enable = true;\n  displayManager.lightdm.enable = true;\n};\nenvironment.systemPackages = with pkgs; [ \n  xorg.xhost # Necessary for allowing docker X11 access \n];\n\nxhost add docker to local drivers with xhost +local:docker or configure from NixOS (warn: I haven’t tried this yet):\n\nsystemd.services.xhost-docker = {\n  description = \"Allow Docker containers to access X11\";\n  after = [ \"display-manager.service\" ];\n  script = ''\n    ${pkgs.xorg.xhost}/bin/xhost +local:docker\n  '';\n  serviceConfig = {\n    Type = \"oneshot\";\n    User = \"root\";\n  };\n  wantedBy = [ \"multi-user.target\" ];\n};"
  },
  {
    "objectID": "posts/unreal-engine-nix.html#more-info",
    "href": "posts/unreal-engine-nix.html#more-info",
    "title": "Unreal Engine on Nix (Linux)",
    "section": "More Info",
    "text": "More Info\nMore information about using Unreal in containers can be found at UnrealContainers, showcasing how to setup docker with correct flags to enable different functionalities.\nFor information on Linux setup: https://dev.epicgames.com/documentation/en-us/unreal-engine/linux-development-quickstart-for-unreal-engine"
  },
  {
    "objectID": "posts/dll-rust.html",
    "href": "posts/dll-rust.html",
    "title": "Rust sys crate for .DLL",
    "section": "",
    "text": "Building a rust *-sys crate is already quite a standard process to reuse stable library that expose a C-ABI and it’s nicely explained in kornel rust-sys-crate blog. While this works great on Unix or with statically linked library, if you had access to the source, a .DLL requires [1] to load it at runtime.\n[1] Or does it? I only managed to work with a dll using libloading crate, while bindgen itself didn’t manage to link it, no matter what flags I passed to the rust compiler.\n\n\nRust statically links the binaries compiled, however, not the dynamic library which needs to be loaded at runtime. In the case of dynamic library which can be linked at runtime because they are in the linker path, nothing else it’s required. However, if we want the executable to be self maintained, the dynamic library path must be given.\nMy first attempt was to use the OUT_DIR, however this expands in an absolute path which is written in the binary as a constant. Hence, changing the path of the executable or transferring it on another machine, breaks it.\n\n\n\nThe alternative I thought is to embed the .dll inside the executable using embed-resource, extract it at runtime and load it with libloading. This idea doesn’t seem to have been explored before, so I have no certainty yet that is works.\n\n\n\nAdd dependency to build step\n\ncargo add --build embed-resource\n\nWrite the windows resource file as follows in an .rc file.\n\n// Define the DLL as an RCDATA resource\nIDR_MYDLL RCDATA \"vendor_library.dll\"\n\nEmbed the dll inside the executable:\n\nfn main() {\n    embed_resource::compile(\"dll_resource.rc\", embed_resource::NONE)\n        .manifest_optional()\n        .unwrap();\n}\n\nExtract dll at runtime and load it with libloading:\n\nuse winapi::um::libloaderapi::{FindResourceW, LoadResource, SizeofResource, LockResource};\nuse winapi::um::winbase::FreeResource;\nuse winapi::um::winuser::RT_RCDATA;\nuse std::ptr;\nuse std::ffi::OsStr;\nuse std::os::windows::ffi::OsStrExt;\nuse libloading::{Library, Symbol};\n\nunsafe fn extract_and_load_dll() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Convert resource name to wide string\n    let resource_name = OsStr::new(\"IDR_MYDLL\").encode_wide().chain(Some(0)).collect::&lt;Vec&lt;_&gt;&gt;();\n    \n    // Locate the resource\n    let h_resource = FindResourceW(\n        ptr::null_mut(),\n        resource_name.as_ptr(),\n        RT_RCDATA\n    );\n    \n    // Load and lock the resource\n    let h_global = LoadResource(ptr::null_mut(), h_resource);\n    let dll_data = LockResource(h_global) as *const u8;\n    let dll_size = SizeofResource(ptr::null_mut(), h_resource) as usize;\n    \n    // Write to temp file\n    let temp_path = std::env::temp_dir().join(\"vendor_library.dll\");\n    std::fs::write(&temp_path, std::slice::from_raw_parts(dll_data, dll_size))?;\n    \n    // Load the DLL\n    let lib = Library::new(&temp_path)?;\n    let func: Symbol&lt;unsafe extern \"C\" fn() -&gt; i32&gt; = lib.get(b\"example_function\")?;\n    println!(\"Result: {}\", func());\n    \n    // Cleanup (optional)\n    FreeResource(h_global);\n    std::fs::remove_file(temp_path)?;\n    \n    Ok(())\n}\nA more detailed example of how to work with embedded resources in Windows is shown in embed and extract binaries into/from exe as resources. In our case the resource type is RCDATA to describe a custom binary."
  },
  {
    "objectID": "posts/dll-rust.html#statically-linked",
    "href": "posts/dll-rust.html#statically-linked",
    "title": "Rust sys crate for .DLL",
    "section": "",
    "text": "Rust statically links the binaries compiled, however, not the dynamic library which needs to be loaded at runtime. In the case of dynamic library which can be linked at runtime because they are in the linker path, nothing else it’s required. However, if we want the executable to be self maintained, the dynamic library path must be given.\nMy first attempt was to use the OUT_DIR, however this expands in an absolute path which is written in the binary as a constant. Hence, changing the path of the executable or transferring it on another machine, breaks it."
  },
  {
    "objectID": "posts/dll-rust.html#embed-resource",
    "href": "posts/dll-rust.html#embed-resource",
    "title": "Rust sys crate for .DLL",
    "section": "",
    "text": "The alternative I thought is to embed the .dll inside the executable using embed-resource, extract it at runtime and load it with libloading. This idea doesn’t seem to have been explored before, so I have no certainty yet that is works.\n\n\n\nAdd dependency to build step\n\ncargo add --build embed-resource\n\nWrite the windows resource file as follows in an .rc file.\n\n// Define the DLL as an RCDATA resource\nIDR_MYDLL RCDATA \"vendor_library.dll\"\n\nEmbed the dll inside the executable:\n\nfn main() {\n    embed_resource::compile(\"dll_resource.rc\", embed_resource::NONE)\n        .manifest_optional()\n        .unwrap();\n}\n\nExtract dll at runtime and load it with libloading:\n\nuse winapi::um::libloaderapi::{FindResourceW, LoadResource, SizeofResource, LockResource};\nuse winapi::um::winbase::FreeResource;\nuse winapi::um::winuser::RT_RCDATA;\nuse std::ptr;\nuse std::ffi::OsStr;\nuse std::os::windows::ffi::OsStrExt;\nuse libloading::{Library, Symbol};\n\nunsafe fn extract_and_load_dll() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Convert resource name to wide string\n    let resource_name = OsStr::new(\"IDR_MYDLL\").encode_wide().chain(Some(0)).collect::&lt;Vec&lt;_&gt;&gt;();\n    \n    // Locate the resource\n    let h_resource = FindResourceW(\n        ptr::null_mut(),\n        resource_name.as_ptr(),\n        RT_RCDATA\n    );\n    \n    // Load and lock the resource\n    let h_global = LoadResource(ptr::null_mut(), h_resource);\n    let dll_data = LockResource(h_global) as *const u8;\n    let dll_size = SizeofResource(ptr::null_mut(), h_resource) as usize;\n    \n    // Write to temp file\n    let temp_path = std::env::temp_dir().join(\"vendor_library.dll\");\n    std::fs::write(&temp_path, std::slice::from_raw_parts(dll_data, dll_size))?;\n    \n    // Load the DLL\n    let lib = Library::new(&temp_path)?;\n    let func: Symbol&lt;unsafe extern \"C\" fn() -&gt; i32&gt; = lib.get(b\"example_function\")?;\n    println!(\"Result: {}\", func());\n    \n    // Cleanup (optional)\n    FreeResource(h_global);\n    std::fs::remove_file(temp_path)?;\n    \n    Ok(())\n}\nA more detailed example of how to work with embedded resources in Windows is shown in embed and extract binaries into/from exe as resources. In our case the resource type is RCDATA to describe a custom binary."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Welcome to my blog! I am a PhD student in University of Edinburgh, researching Multispectral LiDAR development and applications, but my previous experience is in RISC-V and hardware design.\nI have started this blog as a way to dump troubleshooting threads and document things I find interesting."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "crisbour Blog",
    "section": "",
    "text": "Rust sys crate for .DLL\n\n\n\nrust\n\nwindows\n\nffi\n\n\n\n\n\n\n\n\n\nApril 08, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nRust FFI to Julia\n\n\n\nrust\n\nffi\n\njulia\n\n\n\n\n\n\n\n\n\nFebruary 11, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nUnreal Engine on Nix (Linux)\n\n\n\nnix\n\ncontainer\n\nsetup\n\n\n\n\n\n\n\n\n\nNovember 02, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nNovember 02, 2024\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/rust-abi.html",
    "href": "posts/rust-abi.html",
    "title": "Rust FFI to Julia",
    "section": "",
    "text": "== WIP =="
  },
  {
    "objectID": "posts/rust-abi.html#existing-solution",
    "href": "posts/rust-abi.html#existing-solution",
    "title": "Rust FFI to Julia",
    "section": "Existing solution",
    "text": "Existing solution\nYou can call Julia from Rust, using the exposed C FFI for Julia as leveraged by the jlrs crate, but we are also interested about the reverse."
  },
  {
    "objectID": "posts/rust-abi.html#rust-abi",
    "href": "posts/rust-abi.html#rust-abi",
    "title": "Rust FFI to Julia",
    "section": "Rust ABI",
    "text": "Rust ABI\nThere is currently no agreed way even for calling dylib Rust &lt;-&gt; Rust, known as an ABI, this is because the arguments are not assured to have any layout in memory, they are decided arbitrarily when compiled:\nrust abi_stable crate 🤣: &gt; the compiler is free to do whatever it pleases with these aspects of your &gt; software: the process by which it does that is explicitly unstable, and &gt; depends on your compiler version, the optimization level you selected, some &gt; llama’s mood in a wool farm near Berkshire… who knows?\n\nStandard strategy: extern \"C\"\nThe standard way to call Rust through a FFI is translating it into to expose a C interface and reuse the system C-ABI. This however causes to drop many of the guarantees Rust tries to make and induces a huge effort boundary of developing software that empowers these two languages to talk, since the translation effort is required two folds as boilerplate glueing code that doesn’t add any value."
  },
  {
    "objectID": "posts/rust-abi.html#interim-solution-to-ease-integration",
    "href": "posts/rust-abi.html#interim-solution-to-ease-integration",
    "title": "Rust FFI to Julia",
    "section": "Interim solution to ease integration",
    "text": "Interim solution to ease integration\n=&gt; Develop RustCall.jl library similar to PyCall.jl which can use cargo packager to build Rust pacakge and generate the necessary C-FFI shims for the two sides as follows:\n\nConstruct a SAT of the public interface of the Rust library\nLimit the scope of supported types to be translated as follows:\n\nRust::Result&lt;T, dyn Box&lt;Error&gt;&gt; &lt;-&gt; Julia::ResultType{T}: indirect C-FFI WIP workout common representation\nRust::Option&lt;T&gt; &lt;-&gt; Julia::Union{T, Nothing}: simply use C++ union\nPrimitives\n\ninteger and floats can be directly converted\nchar*, CString, CStr, Rust::String, Rust::&str, Julia::String, Julia::SubString =&gt; These need special attentions\n\nenums: ==WARN Julia does not have a first class enum type==, but it depends on the global constant declaration similar to C. On the other side, Rust::enum is more similar to a Julia::Union. Also special care needs to be taken as a common design pattern in Julia is to do multiple dispatch on type hierarchies, whereas Rust dispatches over traits.\nstructs: Every Rust struct must be converted to a C repr struct in order to be exposed through the FFI. The same problem seems to occur with Julia\n\nWhile in Julia or structs are considered to be passed by reference, Rust defines, clone, immutable ref or mutable ref.\n\nWIP: Write some simple tests to understand how structs behave in Julia, but from my observations so far, it’s either immutable or mutable ref based on struct definition rather than function definition."
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  }
]