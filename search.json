[
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "crisbour Blog",
    "section": "",
    "text": "Unreal Engine on Nix (Linux)\n\n\n\n\n\n\nnix\n\n\ncontainer\n\n\nsetup\n\n\n\n\n\n\n\n\n\nNovember 02, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nNovember 02, 2024\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Welcome to my blog! I am a PhD student in University of Edinburgh, researching Multispectral LiDAR development and applications, but my previous experience is in RISC-V and hardware design.\nI have started this blog as a way to dump troubleshooting threads and document things I find interesting."
  },
  {
    "objectID": "posts/unreal-engine-nix.html",
    "href": "posts/unreal-engine-nix.html",
    "title": "Unreal Engine on Nix (Linux)",
    "section": "",
    "text": "The Unreal Engine will be useful for us to generate synthetic data for our research. They provide a prebuild binary for Ubuntu and Centos, however, since I am running NixOS (non FHS system), the prebuilt binary can’t link to the requested libraries.\nTL;DR I have tried a few approaches to get it working on Nix or LXD under Nix, however, in the end I resorted to using their docker image.\n\n\nPrebuilt binaries expecting to run on Linux normally have hard-coded paths in the executable, such as /lib/libstdc++.6.so or even worse the linker itself cannot be found.\n\n\nIn some cases workaround to build and FHS environment fixes the issue. In this scenario, the program is really big (larger than 30GB), so populating a derivation with that amount of extra storage is not acceptable for my laptop, but I have tried to do so:\n{ pkgs ? import&lt;nixpkgs&gt;{}}:\n#stdenv, buildFHSUserEnv, fetchFromGitHub, git, python3, mono, clang, cmake, libGL, xorg }:\n\nlet\n  inherit (pkgs) stdenv buildFHSUserEnv fetchFromGitHub git python3 mono clang cmake libGL xorg;\n  unreal-engine = stdenv.mkDerivation {\n    pname = \"unreal-engine\";\n    version = \"5.4.4\"; # Adjust version as needed\n\n    src = ./.;\n\n    nativeBuildInputs = [ git python3 pkgs.bash stdenv.cc.cc stdenv.cc.cc.lib];\n\n\n    buildInputs = [ \n        libGL \n        xorg.libXi \n        xorg.libXcursor \n        xorg.libXrandr \n        xorg.libXinerama \n    ];\n\n    buildPhase = ''\n      patchShebangs .\n      # Run Setup.sh\n      ./Setup.sh\n      \n      # Generate project files\n      ./GenerateProjectFiles.sh\n      \n      # Build the engine\n      make\n    '';\n\n    installPhase = ''\n      mkdir -p $out\n      cp -r . $out\n    '';\n\n    meta = with pkgs.lib; {\n      description = \"Unreal Engine source code\";\n      homepage = \"https://www.unrealengine.com/\";\n      license = licenses.unfree;\n      platforms = platforms.linux;\n    };\n  };\n\nin\nbuildFHSUserEnv {\n  name = \"unreal-engine-env\";\n  targetPkgs = pkgs: with pkgs; [\n    unreal-engine\n    # Add any additional runtime dependencies here\n  ];\n  runScript = \"bash\";\n}\npatchShebangs overwrites the #!/usb/bin/&lt;executable&gt; paths with the nixpkgs paths in order to fix the build issue. However, this still seems to error with a binary trying to call an utility from a hard-coded path.\n\n\n\nAlso tried to setup an environment using nix-ld to run with libraries paths being patched automagically. ==IDK how nix-ld actually works as I have checked out their source code==\nwith import &lt;nixpkgs&gt; {};\nmkShell {\n  NIX_LD_LIBRARY_PATH = lib.makeLibraryPath [\n    stdenv.cc.cc\n    stdenv.cc.cc.lib\n    SDL2\n    openssl\n    xorg.libX11\n    xorg.libXext\n    xorg.libXcursor\n    xorg.libXrandr\n    xorg.libXinerama\n    libGL\n    libuv\n    # ...\n  ];\n  NIX_LD = lib.fileContents \"${stdenv.cc}/nix-support/dynamic-linker\";\n  shellHook = ''\n    #LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$NIX_LD_LIBRARY_PATH:${pkgs.stdenv.cc.cc.lib}/lib\n    LD_LIBRARY_PATH=${pkgs.stdenv.cc.cc.lib}/lib\n  '';\n}\n\n\n\nNext obvious answer to me was to work in a Distro that UnrealEngine supports by default. Getting LXD to work in NixOS had it’s own complication with forwarding network.\nIn order to get LXD working properly on NixOS, the following is added to the configuration.nix:\n  # Adding lxd and overriding the package\n  virtualisation = {\n    lxd = {\n      enable=true;\n\n      # using the package of our overlay\n      # package = pkgs.lxd-vmx.lxd.override {useQemu = true;};\n      recommendedSysctlSettings=true;\n    };\n\n    lxc = {\n      enable = true;\n      lxcfs.enable = true;\n\n      # This enables lxcfs, which is a FUSE fs that sets up some things so that\n      # things like /proc and cgroups work better in lxd containers.\n      # See https://linuxcontainers.org/lxcfs/introduction/ for more info.\n      #\n      # Also note that the lxcfs NixOS option says that in order to make use of\n      # lxcfs in the container, you need to include the following NixOS setting\n      # in the NixOS container guest configuration:\n      #\n      defaultConfig = \"lxc.include = ''${pkgs.lxcfs}/share/lxc/config/common.conf.d/00-lxcfs.conf\";\n\n      # TODO Add systemConfig to store lxcpath and btrfs.root paths\n      #systemConfig =\n      #  ''\n      #    lxc.lxcpath = /var/lib/lxd/storage-pools # The location in which all containers are stored.\n      #  '';\n    };\n\n    libvirtd = {\n      enable = true;\n      qemu.runAsRoot = true;\n    };\n  };\n\n  # kernel module for forwarding to work\n  boot.kernelModules = [ \"nf_nat_ftp\" ];\n\n  # Set up networking bridge for LXD\n  networking = {\n    bridges = {\n      lxdbr0 = {\n        interfaces = [];\n      };\n    };\n    nat = {\n      enable = true;\n      internalInterfaces = [\"lxdbr0\"];\n      externalInterface = \"eth0\"; # Replace with your actual external interface\n    };\n  };\n  networking.firewall.trustedInterfaces = [ \"lxdbr0\" ];\nWhile the github repository compiled, it didn’t finish linking due to an error I couldn’t debug. ==I haven’t tried the prebuilt binary for this one==\n\n\n\nLuckly it seems that EpicGames provide a docker image for their releases of Unreal as well.\nIn order to access them you need to generate a personal autorisation token: Profile &gt; Settings &gt; Developer settings &gt; Personal access token &gt; Tokens (classic). Enable read: registry for this token. Then login into the ghcr with docker:\nexport GH_PAT=&lt;copy_token_here&gt;\necho $GH_PAT | docker login ghcr.io -u &lt;username&gt; --password-stdin\nThen pull the image of interest, i.e.\ndocker pull ghcr.io/epicgames/unreal-engine:dev-5.4.4\nNow in order to run your container with Xserver support and GPU passthrough, run:\ndocker run --rm -ti --device nvidia.com/gpu=all -v/tmp/.X11-unix:/tmp/.X11-unix:rw -e DISPLAY --network host ghcr.io/epicgames/unreal-engine:dev-5.4.3 bash\n\n\nThere are a few details to iron out in order to make the above command work. For NixOS the followings:\n\nEnsure docker is enable and has support for nvidia:\n\n  virtualisation.docker = {\n    enable = true;\n  };\n  hardware.nvidia-container-toolkit.enable = true;\n\n  users.users.cristi.extraGroups = [\"docker\"];\n\n  environment.systemPackages = with pkgs; [\n    docker\n  ];\n\nEnsure xserver is enabled and can allow docker\n\nservices.xserver = {\n  enable = true;\n  displayManager.lightdm.enable = true;\n};\nenvironment.systemPackages = with pkgs; [ \n  xorg.xhost # Necessary for allowing docker X11 access \n];\n\nxhost add docker to local drivers with xhost +local:docker or configure from NixOS (warn: I haven’t tried this yet):\n\nsystemd.services.xhost-docker = {\n  description = \"Allow Docker containers to access X11\";\n  after = [ \"display-manager.service\" ];\n  script = ''\n    ${pkgs.xorg.xhost}/bin/xhost +local:docker\n  '';\n  serviceConfig = {\n    Type = \"oneshot\";\n    User = \"root\";\n  };\n  wantedBy = [ \"multi-user.target\" ];\n};"
  },
  {
    "objectID": "posts/unreal-engine-nix.html#running-on-nix",
    "href": "posts/unreal-engine-nix.html#running-on-nix",
    "title": "Unreal Engine on Nix (Linux)",
    "section": "",
    "text": "Prebuilt binaries expecting to run on Linux normally have hard-coded paths in the executable, such as /lib/libstdc++.6.so or even worse the linker itself cannot be found.\n\n\nIn some cases workaround to build and FHS environment fixes the issue. In this scenario, the program is really big (larger than 30GB), so populating a derivation with that amount of extra storage is not acceptable for my laptop, but I have tried to do so:\n{ pkgs ? import&lt;nixpkgs&gt;{}}:\n#stdenv, buildFHSUserEnv, fetchFromGitHub, git, python3, mono, clang, cmake, libGL, xorg }:\n\nlet\n  inherit (pkgs) stdenv buildFHSUserEnv fetchFromGitHub git python3 mono clang cmake libGL xorg;\n  unreal-engine = stdenv.mkDerivation {\n    pname = \"unreal-engine\";\n    version = \"5.4.4\"; # Adjust version as needed\n\n    src = ./.;\n\n    nativeBuildInputs = [ git python3 pkgs.bash stdenv.cc.cc stdenv.cc.cc.lib];\n\n\n    buildInputs = [ \n        libGL \n        xorg.libXi \n        xorg.libXcursor \n        xorg.libXrandr \n        xorg.libXinerama \n    ];\n\n    buildPhase = ''\n      patchShebangs .\n      # Run Setup.sh\n      ./Setup.sh\n      \n      # Generate project files\n      ./GenerateProjectFiles.sh\n      \n      # Build the engine\n      make\n    '';\n\n    installPhase = ''\n      mkdir -p $out\n      cp -r . $out\n    '';\n\n    meta = with pkgs.lib; {\n      description = \"Unreal Engine source code\";\n      homepage = \"https://www.unrealengine.com/\";\n      license = licenses.unfree;\n      platforms = platforms.linux;\n    };\n  };\n\nin\nbuildFHSUserEnv {\n  name = \"unreal-engine-env\";\n  targetPkgs = pkgs: with pkgs; [\n    unreal-engine\n    # Add any additional runtime dependencies here\n  ];\n  runScript = \"bash\";\n}\npatchShebangs overwrites the #!/usb/bin/&lt;executable&gt; paths with the nixpkgs paths in order to fix the build issue. However, this still seems to error with a binary trying to call an utility from a hard-coded path.\n\n\n\nAlso tried to setup an environment using nix-ld to run with libraries paths being patched automagically. ==IDK how nix-ld actually works as I have checked out their source code==\nwith import &lt;nixpkgs&gt; {};\nmkShell {\n  NIX_LD_LIBRARY_PATH = lib.makeLibraryPath [\n    stdenv.cc.cc\n    stdenv.cc.cc.lib\n    SDL2\n    openssl\n    xorg.libX11\n    xorg.libXext\n    xorg.libXcursor\n    xorg.libXrandr\n    xorg.libXinerama\n    libGL\n    libuv\n    # ...\n  ];\n  NIX_LD = lib.fileContents \"${stdenv.cc}/nix-support/dynamic-linker\";\n  shellHook = ''\n    #LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$NIX_LD_LIBRARY_PATH:${pkgs.stdenv.cc.cc.lib}/lib\n    LD_LIBRARY_PATH=${pkgs.stdenv.cc.cc.lib}/lib\n  '';\n}\n\n\n\nNext obvious answer to me was to work in a Distro that UnrealEngine supports by default. Getting LXD to work in NixOS had it’s own complication with forwarding network.\nIn order to get LXD working properly on NixOS, the following is added to the configuration.nix:\n  # Adding lxd and overriding the package\n  virtualisation = {\n    lxd = {\n      enable=true;\n\n      # using the package of our overlay\n      # package = pkgs.lxd-vmx.lxd.override {useQemu = true;};\n      recommendedSysctlSettings=true;\n    };\n\n    lxc = {\n      enable = true;\n      lxcfs.enable = true;\n\n      # This enables lxcfs, which is a FUSE fs that sets up some things so that\n      # things like /proc and cgroups work better in lxd containers.\n      # See https://linuxcontainers.org/lxcfs/introduction/ for more info.\n      #\n      # Also note that the lxcfs NixOS option says that in order to make use of\n      # lxcfs in the container, you need to include the following NixOS setting\n      # in the NixOS container guest configuration:\n      #\n      defaultConfig = \"lxc.include = ''${pkgs.lxcfs}/share/lxc/config/common.conf.d/00-lxcfs.conf\";\n\n      # TODO Add systemConfig to store lxcpath and btrfs.root paths\n      #systemConfig =\n      #  ''\n      #    lxc.lxcpath = /var/lib/lxd/storage-pools # The location in which all containers are stored.\n      #  '';\n    };\n\n    libvirtd = {\n      enable = true;\n      qemu.runAsRoot = true;\n    };\n  };\n\n  # kernel module for forwarding to work\n  boot.kernelModules = [ \"nf_nat_ftp\" ];\n\n  # Set up networking bridge for LXD\n  networking = {\n    bridges = {\n      lxdbr0 = {\n        interfaces = [];\n      };\n    };\n    nat = {\n      enable = true;\n      internalInterfaces = [\"lxdbr0\"];\n      externalInterface = \"eth0\"; # Replace with your actual external interface\n    };\n  };\n  networking.firewall.trustedInterfaces = [ \"lxdbr0\" ];\nWhile the github repository compiled, it didn’t finish linking due to an error I couldn’t debug. ==I haven’t tried the prebuilt binary for this one==\n\n\n\nLuckly it seems that EpicGames provide a docker image for their releases of Unreal as well.\nIn order to access them you need to generate a personal autorisation token: Profile &gt; Settings &gt; Developer settings &gt; Personal access token &gt; Tokens (classic). Enable read: registry for this token. Then login into the ghcr with docker:\nexport GH_PAT=&lt;copy_token_here&gt;\necho $GH_PAT | docker login ghcr.io -u &lt;username&gt; --password-stdin\nThen pull the image of interest, i.e.\ndocker pull ghcr.io/epicgames/unreal-engine:dev-5.4.4\nNow in order to run your container with Xserver support and GPU passthrough, run:\ndocker run --rm -ti --device nvidia.com/gpu=all -v/tmp/.X11-unix:/tmp/.X11-unix:rw -e DISPLAY --network host ghcr.io/epicgames/unreal-engine:dev-5.4.3 bash\n\n\nThere are a few details to iron out in order to make the above command work. For NixOS the followings:\n\nEnsure docker is enable and has support for nvidia:\n\n  virtualisation.docker = {\n    enable = true;\n  };\n  hardware.nvidia-container-toolkit.enable = true;\n\n  users.users.cristi.extraGroups = [\"docker\"];\n\n  environment.systemPackages = with pkgs; [\n    docker\n  ];\n\nEnsure xserver is enabled and can allow docker\n\nservices.xserver = {\n  enable = true;\n  displayManager.lightdm.enable = true;\n};\nenvironment.systemPackages = with pkgs; [ \n  xorg.xhost # Necessary for allowing docker X11 access \n];\n\nxhost add docker to local drivers with xhost +local:docker or configure from NixOS (warn: I haven’t tried this yet):\n\nsystemd.services.xhost-docker = {\n  description = \"Allow Docker containers to access X11\";\n  after = [ \"display-manager.service\" ];\n  script = ''\n    ${pkgs.xorg.xhost}/bin/xhost +local:docker\n  '';\n  serviceConfig = {\n    Type = \"oneshot\";\n    User = \"root\";\n  };\n  wantedBy = [ \"multi-user.target\" ];\n};"
  }
]