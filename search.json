[
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "posts/unreal-engine-nix.html",
    "href": "posts/unreal-engine-nix.html",
    "title": "Unreal Engine on Nix (Linux)",
    "section": "",
    "text": "The Unreal Engine will be useful for us to generate synthetic data for our research. They provide a prebuild binary for Ubuntu and Centos, however, since I am running NixOS (non FHS system), the prebuilt binary can’t link to the requested libraries.\nTL;DR I have tried a few approaches to get it working on Nix or LXD under Nix, however, in the end I resorted to using their docker image."
  },
  {
    "objectID": "posts/unreal-engine-nix.html#fhsuserenv",
    "href": "posts/unreal-engine-nix.html#fhsuserenv",
    "title": "Unreal Engine on Nix (Linux)",
    "section": "FHSUserEnv",
    "text": "FHSUserEnv\nIn some cases workaround to build and FHS environment fixes the issue. In this scenario, the program is really big (larger than 30GB), so populating a derivation with that amount of extra storage is not acceptable for my laptop, but I have tried to do so:\n{ pkgs ? import&lt;nixpkgs&gt;{}}:\n#stdenv, buildFHSUserEnv, fetchFromGitHub, git, python3, mono, clang, cmake, libGL, xorg }:\n\nlet\n  inherit (pkgs) stdenv buildFHSUserEnv fetchFromGitHub git python3 mono clang cmake libGL xorg;\n  unreal-engine = stdenv.mkDerivation {\n    pname = \"unreal-engine\";\n    version = \"5.4.4\"; # Adjust version as needed\n\n    src = ./.;\n\n    nativeBuildInputs = [ git python3 pkgs.bash stdenv.cc.cc stdenv.cc.cc.lib];\n\n\n    buildInputs = [ \n        libGL \n        xorg.libXi \n        xorg.libXcursor \n        xorg.libXrandr \n        xorg.libXinerama \n    ];\n\n    buildPhase = ''\n      patchShebangs .\n      # Run Setup.sh\n      ./Setup.sh\n      \n      # Generate project files\n      ./GenerateProjectFiles.sh\n      \n      # Build the engine\n      make\n    '';\n\n    installPhase = ''\n      mkdir -p $out\n      cp -r . $out\n    '';\n\n    meta = with pkgs.lib; {\n      description = \"Unreal Engine source code\";\n      homepage = \"https://www.unrealengine.com/\";\n      license = licenses.unfree;\n      platforms = platforms.linux;\n    };\n  };\n\nin\nbuildFHSUserEnv {\n  name = \"unreal-engine-env\";\n  targetPkgs = pkgs: with pkgs; [\n    unreal-engine\n    # Add any additional runtime dependencies here\n  ];\n  runScript = \"bash\";\n}\npatchShebangs overwrites the #!/usb/bin/&lt;executable&gt; paths with the nixpkgs paths in order to fix the build issue. However, this still seems to error with a binary trying to call an utility from a hard-coded path."
  },
  {
    "objectID": "posts/unreal-engine-nix.html#nix-ld",
    "href": "posts/unreal-engine-nix.html#nix-ld",
    "title": "Unreal Engine on Nix (Linux)",
    "section": "nix-ld",
    "text": "nix-ld\nAlso tried to setup an environment using nix-ld to run with libraries paths being patched automagically. ==IDK how nix-ld actually works as I have checked out their source code==\nwith import &lt;nixpkgs&gt; {};\nmkShell {\n  NIX_LD_LIBRARY_PATH = lib.makeLibraryPath [\n    stdenv.cc.cc\n    stdenv.cc.cc.lib\n    SDL2\n    openssl\n    xorg.libX11\n    xorg.libXext\n    xorg.libXcursor\n    xorg.libXrandr\n    xorg.libXinerama\n    libGL\n    libuv\n    # ...\n  ];\n  NIX_LD = lib.fileContents \"${stdenv.cc}/nix-support/dynamic-linker\";\n  shellHook = ''\n    #LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$NIX_LD_LIBRARY_PATH:${pkgs.stdenv.cc.cc.lib}/lib\n    LD_LIBRARY_PATH=${pkgs.stdenv.cc.cc.lib}/lib\n  '';\n}"
  },
  {
    "objectID": "posts/unreal-engine-nix.html#lxd",
    "href": "posts/unreal-engine-nix.html#lxd",
    "title": "Unreal Engine on Nix (Linux)",
    "section": "LXD",
    "text": "LXD\nNext obvious answer to me was to work in a Distro that UnrealEngine supports by default. Getting LXD to work in NixOS had it’s own complication with forwarding network.\nIn order to get LXD working properly on NixOS, the following is added to the configuration.nix:\n  # Adding lxd and overriding the package\n  virtualisation = {\n    lxd = {\n      enable=true;\n\n      # using the package of our overlay\n      # package = pkgs.lxd-vmx.lxd.override {useQemu = true;};\n      recommendedSysctlSettings=true;\n    };\n\n    lxc = {\n      enable = true;\n      lxcfs.enable = true;\n\n      # This enables lxcfs, which is a FUSE fs that sets up some things so that\n      # things like /proc and cgroups work better in lxd containers.\n      # See https://linuxcontainers.org/lxcfs/introduction/ for more info.\n      #\n      # Also note that the lxcfs NixOS option says that in order to make use of\n      # lxcfs in the container, you need to include the following NixOS setting\n      # in the NixOS container guest configuration:\n      #\n      defaultConfig = \"lxc.include = ''${pkgs.lxcfs}/share/lxc/config/common.conf.d/00-lxcfs.conf\";\n\n      # TODO Add systemConfig to store lxcpath and btrfs.root paths\n      #systemConfig =\n      #  ''\n      #    lxc.lxcpath = /var/lib/lxd/storage-pools # The location in which all containers are stored.\n      #  '';\n    };\n\n    libvirtd = {\n      enable = true;\n      qemu.runAsRoot = true;\n    };\n  };\n\n  # kernel module for forwarding to work\n  boot.kernelModules = [ \"nf_nat_ftp\" ];\n\n  # Set up networking bridge for LXD\n  networking = {\n    bridges = {\n      lxdbr0 = {\n        interfaces = [];\n      };\n    };\n    nat = {\n      enable = true;\n      internalInterfaces = [\"lxdbr0\"];\n      externalInterface = \"eth0\"; # Replace with your actual external interface\n    };\n  };\n  networking.firewall.trustedInterfaces = [ \"lxdbr0\" ];\nWhile the github repository compiled, it didn’t finish linking due to an error I couldn’t debug. ==I haven’t tried the prebuilt binary for this one=="
  },
  {
    "objectID": "posts/unreal-engine-nix.html#docker",
    "href": "posts/unreal-engine-nix.html#docker",
    "title": "Unreal Engine on Nix (Linux)",
    "section": "Docker",
    "text": "Docker\nLuckly it seems that EpicGames provide a docker image for their releases of Unreal as well.\nFirst of all, become a member of the EpicGames github group in order to access repositories and registry. Follow Getting started with Unreal Engine source code access.\nIn order to access them you need to generate a personal autorisation token: Profile &gt; Settings &gt; Developer settings &gt; Personal access token &gt; Tokens (classic). Enable read: packages for this token. Then login into the ghcr with docker:\nexport GH_PAT=&lt;copy_token_here&gt;\necho $GH_PAT | docker login ghcr.io -u &lt;username&gt; --password-stdin\nThen pull the image of interest, i.e.\ndocker pull ghcr.io/epicgames/unreal-engine:dev-5.4.4\nNow in order to run your container with Xserver support and GPU passthrough, run:\ndocker run --rm -ti --device nvidia.com/gpu=all -v/tmp/.X11-unix:/tmp/.X11-unix:rw -e DISPLAY --network host ghcr.io/epicgames/unreal-engine:dev-5.4.3 bash\n\nGPU, Xserver and network to Docker\nThere are a few details to iron out in order to make the above command work. For NixOS the followings:\n\nEnsure docker is enable and has support for nvidia:\n\n  virtualisation.docker = {\n    enable = true;\n  };\n  hardware.nvidia-container-toolkit.enable = true;\n\n  users.users.cristi.extraGroups = [\"docker\"];\n\n  environment.systemPackages = with pkgs; [\n    docker\n  ];\n\nEnsure xserver is enabled and can allow docker\n\nservices.xserver = {\n  enable = true;\n  displayManager.lightdm.enable = true;\n};\nenvironment.systemPackages = with pkgs; [ \n  xorg.xhost # Necessary for allowing docker X11 access \n];\n\nxhost add docker to local drivers with xhost +local:docker or configure from NixOS (warn: I haven’t tried this yet):\n\nsystemd.services.xhost-docker = {\n  description = \"Allow Docker containers to access X11\";\n  after = [ \"display-manager.service\" ];\n  script = ''\n    ${pkgs.xorg.xhost}/bin/xhost +local:docker\n  '';\n  serviceConfig = {\n    Type = \"oneshot\";\n    User = \"root\";\n  };\n  wantedBy = [ \"multi-user.target\" ];\n};"
  },
  {
    "objectID": "posts/unreal-engine-nix.html#more-info",
    "href": "posts/unreal-engine-nix.html#more-info",
    "title": "Unreal Engine on Nix (Linux)",
    "section": "More Info",
    "text": "More Info\nMore information about using Unreal in containers can be found at UnrealContainers, showcasing how to setup docker with correct flags to enable different functionalities.\nFor information on Linux setup: https://dev.epicgames.com/documentation/en-us/unreal-engine/linux-development-quickstart-for-unreal-engine"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Welcome to my blog! I am a PhD student in University of Edinburgh, researching Multispectral LiDAR development and applications, but my previous experience is in RISC-V and hardware design.\nI have started this blog as a way to dump troubleshooting threads and document things I find interesting."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "crisbour Blog",
    "section": "",
    "text": "Rust FFI to Julia\n\n\n\nrust\n\nffi\n\njulia\n\n\n\n\n\n\n\n\n\nFebruary 11, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nUnreal Engine on Nix (Linux)\n\n\n\nnix\n\ncontainer\n\nsetup\n\n\n\n\n\n\n\n\n\nNovember 02, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nNovember 02, 2024\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/rust-abi.html",
    "href": "posts/rust-abi.html",
    "title": "Rust FFI to Julia",
    "section": "",
    "text": "== WIP =="
  },
  {
    "objectID": "posts/rust-abi.html#existing-solution",
    "href": "posts/rust-abi.html#existing-solution",
    "title": "Rust FFI to Julia",
    "section": "Existing solution",
    "text": "Existing solution\nYou can call Julia from Rust, using the exposed C FFI for Julia as leveraged by the jlrs crate, but we are also interested about the reverse."
  },
  {
    "objectID": "posts/rust-abi.html#rust-abi",
    "href": "posts/rust-abi.html#rust-abi",
    "title": "Rust FFI to Julia",
    "section": "Rust ABI",
    "text": "Rust ABI\nThere is currently no agreed way even for calling dylib Rust &lt;-&gt; Rust, known as an ABI, this is because the arguments are not assured to have any layout in memory, they are decided arbitrarily when compiled:\nrust abi_stable crate 🤣: &gt; the compiler is free to do whatever it pleases with these aspects of your &gt; software: the process by which it does that is explicitly unstable, and &gt; depends on your compiler version, the optimization level you selected, some &gt; llama’s mood in a wool farm near Berkshire… who knows?\n\nStandard strategy: extern \"C\"\nThe standard way to call Rust through a FFI is translating it into to expose a C interface and reuse the system C-ABI. This however causes to drop many of the guarantees Rust tries to make and induces a huge effort boundary of developing software that empowers these two languages to talk, since the translation effort is required two folds as boilerplate glueing code that doesn’t add any value."
  },
  {
    "objectID": "posts/rust-abi.html#interim-solution-to-ease-integration",
    "href": "posts/rust-abi.html#interim-solution-to-ease-integration",
    "title": "Rust FFI to Julia",
    "section": "Interim solution to ease integration",
    "text": "Interim solution to ease integration\n=&gt; Develop RustCall.jl library similar to PyCall.jl which can use cargo packager to build Rust pacakge and generate the necessary C-FFI shims for the two sides as follows:\n\nConstruct a SAT of the public interface of the Rust library\nLimit the scope of supported types to be translated as follows:\n\nRust::Result&lt;T, dyn Box&lt;Error&gt;&gt; &lt;-&gt; Julia::ResultType{T}: indirect C-FFI WIP workout common representation\nRust::Option&lt;T&gt; &lt;-&gt; Julia::Union{T, Nothing}: simply use C++ union\nPrimitives\n\ninteger and floats can be directly converted\nchar*, CString, CStr, Rust::String, Rust::&str, Julia::String, Julia::SubString =&gt; These need special attentions\n\nenums: ==WARN Julia does not have a first class enum type==, but it depends on the global constant declaration similar to C. On the other side, Rust::enum is more similar to a Julia::Union. Also special care needs to be taken as a common design pattern in Julia is to do multiple dispatch on type hierarchies, whereas Rust dispatches over traits.\nstructs: Every Rust struct must be converted to a C repr struct in order to be exposed through the FFI. The same problem seems to occur with Julia\n\nWhile in Julia or structs are considered to be passed by reference, Rust defines, clone, immutable ref or mutable ref.\n\nWIP: Write some simple tests to understand how structs behave in Julia, but from my observations so far, it’s either immutable or mutable ref based on struct definition rather than function definition."
  }
]